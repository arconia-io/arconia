= Arconia OpenTelemetry

Arconia OpenTelemetry simplifies observability for Spring Boot applications by combining the standardization of https://opentelemetry.io/docs/what-is-opentelemetry/[OpenTelemetry] with the robustness of https://micrometer.io[Micrometer] to deliver a unified solution that covers all your telemetry needs.

Need to collect, process, and export logs, metrics, and traces from your Spring Boot applications? Add the Arconia OpenTelemetry Spring Boot Starter to your project and get everything you need in one dependency.

Observability is not just for production. If you're looking to enhance your development and testing experience, xref:dev-services:index.adoc[Arconia Dev Services] offers a zero-code and zero-config integration with xref:dev-services:lgtm.adoc[Grafana LGTM], providing a complete OpenTelemetry observability platform right in your development environment.

TIP: If you're currently using OpenTelemetry Spring Boot Starter or Spring Boot OpenTelemetry/OTLP, check out our xref:migration.adoc[Migration Guides] for a seamless migration to Arconia OpenTelemetry.

== Quick Start

Let's see how you can get started with Arconia OpenTelemetry in your Spring Boot application.

TIP: You can refer to our https://github.com/arconia-io/arconia-examples/tree/main/arconia-opentelemetry/observability-signals[sample application] for a minimal example of how Arconia OpenTelemetry works.

=== Dependencies

If you already have a Spring Boot application and want to add OpenTelemetry support, you can add the Arconia OpenTelemetry Spring Boot Starter dependency to your project. This will automatically configure OpenTelemetry, Micrometer, and Spring Boot Actuator for you.

[tabs]
======
Gradle::
+
[source,groovy]
----
dependencies {
    implementation 'io.arconia:arconia-opentelemetry-spring-boot-starter'
}
----

Maven::
+
[source,xml]
----
<dependency>
    <groupId>io.arconia</groupId>
    <artifactId>arconia-opentelemetry-spring-boot-starter</artifactId>
</dependency>
----
======

Arconia publishes a BOM (Bill of Materials) that you can use to manage the version of the Arconia libraries. It is highly recommended to use the BOM to ensure that all dependencies are compatible.

[tabs]
======
Gradle::
+
[source,groovy,subs="attributes"]
----
dependencyManagement {
	imports {
		mavenBom "io.arconia:arconia-bom:{page-component-version}"
	}
}
----

Maven::
+
[source,xml,subs="attributes,verbatim"]
----
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>io.arconia</groupId>
            <artifactId>arconia-bom</artifactId>
            <version>{page-component-version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
----
======

=== Dev Services

xref:dev-services:index.adoc[Arconia Dev Services] streamline your development workflow by automatically provisioning external services your application depends on during development and testing. No manual setup is required.

With Arconia OpenTelemetry, you can leverage the xref:dev-services:lgtm.adoc[Grafana LGTM Dev Service] to automatically start a complete Grafana observability platform based on OpenTelemetry, allowing you to visualize and explore your application's telemetry data during development and testing.

To enable the Grafana LGTM Dev Service, add the following dependency to your project:

[tabs]
======
Gradle::
+
[source,groovy]
----
dependencies {
    testAndDevelopmentOnly "io.arconia:arconia-dev-services-lgtm"
}
----

Maven::
+
[source,xml]
----
<dependency>
    <groupId>io.arconia</groupId>
    <artifactId>arconia-dev-services-lgtm</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
----
======

NOTE: Arconia also provides the xref:dev-services:phoenix.adoc[Arize Phoenix Dev Service] if you're looking for an AI Observability and Evaluation platform based on OpenTelemetry.

=== Running the Application

You can run your Spring Boot application using your preferred method.

include::ROOT:partial$app-run.adoc[]

If you have enabled the Grafana LGTM Dev Service, Arconia will automatically start a Grafana instance pre-configured to accept OpenTelemetry logs, metrics, and traces from your application when running in development or test mode.

NOTE: By default, when running the application in development mode, the Grafana LGTM Dev Service will be shared across multiple applications so that you can have a single observability platform for all your applications running in your development environment.

The application logs will show you the URL where you can access the Grafana observability platform and start exploring your application's telemetry data.

[source,logs]
----
...o.t.grafana.LgtmStackContainer: Access to the Grafana dashboard: http://localhost:<port>
----

NOTE: Learn more about the xref:dev-services:lgtm.adoc[Grafana LGTM Dev Service] in the dedicated documentation.

== Enabling/Disabling Telemetry

The Arconia OpenTelemetry Spring Boot Starter provides sensible defaults for configuring observability signals. By default, logs, metrics, and traces are enabled and exported via OTLP to an OpenTelemetry-compatible backend.

You can disable individual observability signals or even disable the entire OpenTelemetry support via configuration properties.

.Observability Signals Configuration Properties
|===
|Property |Default |Description

|`arconia.otel.enabled`
|`true`
|Whether OpenTelemetry support should be enabled.

|`arconia.otel.logs.enabled`
|`true`
|Whether support for OpenTelemetry logs is enabled.

|`arconia.otel.metrics.enabled`
|`true`
|Whether support for OpenTelemetry metrics is enabled.

|`arconia.otel.traces.enabled`
|`true`
|Whether support for OpenTelemetry traces is enabled.
|===

== Exporting Telemetry

By default, all observability signals are exported via OTLP. If you set the exporter type to `none`, the observability signals will be disabled from exporting.

.Exporter Type Configuration Properties
|===
|Property |Default |Description
|`arconia.otel.exporter.type`
|`otlp`
|The type of OpenTelemetry exporter to use for observability signals. Options: `console`, `otlp`, `none`.
|===

You can change the type of the exporter in use for each observability signal using the `arconia.otel.<signal>.exporter.type` property, where `<signal>` is one of `logs`, `metrics`, or `traces`.

.Specific Exporter Type Configuration Properties
|===
|Property |Default |Description
|`arconia.otel.logs.exporter.type`
|_(inherited from arconia.otel.exporter.type)_
|The type of OpenTelemetry exporter to use for logs. Options: `console`, `otlp`, `none`.
|`arconia.otel.metrics.exporter.type`
|_(inherited from arconia.otel.exporter.type)_
|The type of OpenTelemetry exporter to use for metrics. Options: `console`, `otlp`, `none`.
|`arconia.otel.traces.exporter.type`
|_(inherited from arconia.otel.exporter.type)_
|The type of OpenTelemetry exporter to use for traces. Options: `console`, `otlp`, `none`.
|===

=== OTLP

Global properties are available to configure the OTLP exporters for logs, metrics, and traces.

.OTLP Exporter Configuration Properties
|===
|Property |Default |Description
|`arconia.otel.exporter.otlp.compression`
|`gzip`
|Compression type to use for OTLP requests. Options: `none`, `gzip`.

|`arconia.otel.exporter.otlp.connect-timeout`
|`10s`
|The maximum waiting time for the exporter to establish a connection to the endpoint.

|`arconia.otel.exporter.otlp.endpoint`
|`http://localhost:4317` (gPRC) or `http://localhost:4318` (HTTP)
|The endpoint to which telemetry data will be sent.

|`arconia.otel.exporter.otlp.headers`
|-
|Additional headers to include in each request to the endpoint.

|`arconia.otel.exporter.otlp.metrics`
|`false`
|Whether to generate metrics for the exporter itself.

|`arconia.otel.exporter.otlp.protocol`
|`http-protobuf`
|Transport protocol to use for OTLP requests. Options: `grpc`, `http-protobuf`.

|`arconia.otel.exporter.otlp.timeout`
|`10s`
|The maximum waiting time for the exporter to send each telemetry batch.

|`arconia.otel.exporter.memory-mode`
|`reusable-data`
|Whether to reuse objects to reduce allocation or work with immutable data structures. Options: `reusable-data`, `immutable-data`.

|`arconia.otel.exporter.otlp.retry.max-attempts`
|`5`
|Maximum number of retries.

|`arconia.otel.exporter.otlp.retry.backoff-config.first-backoff`
|`1s`
|Initial backoff time.

|`arconia.otel.exporter.otlp.retry.backoff-config.max-backoff`
|`5s`
|Maximum backoff time.

|`arconia.otel.exporter.otlp.retry.backoff-config.multiplier`
|`1.5`
|Backoff multiplier.

|===

You can override any of these properties for each observability signal using the `arconia.otel.<signal>.exporter.*` prefix, where `<signal>` is one of `logs`, `metrics`, or `traces`. For more details, refer to the dedicated documentation for xref:logs.adoc[Logs], xref:metrics.adoc[Metrics], and xref:traces.adoc[Traces].

==== HTTP

By default, the OpenTelemetry SDK uses HTTP/Protobuf for OTLP communication. In particular, it relies on the https://opentelemetry.io/docs/languages/java/sdk/#senders[JDK Http Client] to send telemetry data to the endpoint.

==== gRPC

You can switch to gRPC by changing the `arconia.otel.exporter.otlp.protocol` property to `grpc`. Additionally, you need to add the following dependency:

[tabs]
======
Gradle::
+
[source,groovy]
----
dependencies {
    implementation "io.opentelemetry:opentelemetry-exporter-sender-grpc-managed-channel"
}
----

Maven::
+
[source,xml]
----
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-exporter-sender-grpc-managed-channel</artifactId>
</dependency>
----
======

The https://opentelemetry.io/docs/languages/java/sdk/#senders[`opentelemetry-exporter-sender-grpc-managed-channel`] requires a transport implementation among the ones provided by the https://github.com/grpc/grpc-java[grpc-java] project. The `grpc-netty-shaded` dependency is one choice, but you can use any other gRPC transport implementation that fits your needs. Arconia doesn't manage this dependency for you, so make sure to include it in your project and specify a version. The OpenTelemetry project doesn't provide any guidance on which version of https://github.com/grpc/grpc-java[grpc-java] to use. Our recommendation is to use the latest 1.x version.

[tabs]
======
Gradle::
+
[source,groovy]
----
dependencies {
    runtimeOnly "io.grpc:grpc-netty-shaded:{version}"
}
----

Maven::
+
[source,xml]
----
<dependency>
    <groupId>io.grpc</groupId>
    <artifactId>grpc-netty-shaded</artifactId>
    <version>{version}</version>
</dependency>
----
======

=== Console

Instead of OTLP, you can use the console exporter to print the telemetry data to the console. This is useful for debugging and testing purposes. Besides setting the exporter type to `console` for the observability signals you want to export, you also need to add the following dependency:

[tabs]
======
Gradle::
+
[source,groovy]
----
dependencies {
    implementation "io.opentelemetry:opentelemetry-exporter-logging"
}
----

Maven::
+
[source,xml]
----
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-exporter-logging</artifactId>
</dependency>
----
======

WARNING: This exporter option is not recommended for production.

NOTE: The console exporter doesn't support exporting metrics defined using the Micrometer APIs when using the Micrometer Metrics Registry OTLP module instead of the OpenTelemetry Micrometer Metrics Bridge.

== OpenTelemetry Environment Variables

include::partial$opentelemetry-environment-variables.adoc[]

== Comparisons

Arconia provides unified observability for Spring Boot applications, combining full support for https://opentelemetry.io/docs/what-is-opentelemetry/[OpenTelemetry] API, SDK, and Instrumentation with full support for https://micrometer.io[Micrometer] API and Instrumentation. The goal is to provide a single, unified observability solution for Spring Boot applications that can give you the best of both worlds: the standardization and ubiquity of OpenTelemetry and the robustness and stability of Micrometer.

image::arconia-otel.png[Arconia provides full support for OpenTelemetry and Micrometer, width=500]

The main reason why Arconia OpenTelemetry exists is that no other option provides this level of integration and support for both OpenTelemetry and Micrometer in a single, unified solution. This section compares Arconia OpenTelemetry with other solutions available in the Spring Boot ecosystem (see the comparison table below).

.Differences between Arconia OpenTelemetry and other solutions
[cols="2,1,1,1,1", options="header"]
|===
| Aspect | Arconia OpenTelemetry | Spring Boot 3 | Spring Boot 4 | OpenTelemetry Spring Boot Starter
| OpenTelemetry Logging API | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ
| OpenTelemetry Metrics API | ‚úÖ | ‚ùå | ‚ùå | ‚úÖ
| OpenTelemetry Tracing API | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ
| Logback Logging Bridge for OpenTelemetry API | ‚úÖ | ‚ùå | ‚ùå | ‚úÖ
| Log4J2 Logging Bridge for OpenTelemetry API | üöß | ‚ùå | ‚ùå | ‚úÖ
| Micrometer Metrics Bridge for OpenTelemetry API | ‚úÖ | ‚ùå | ‚ùå | ‚úÖ
| Micrometer Tracing Bridge for OpenTelemetry API | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå
| OpenTelemetry OTLP Logs Exporter | ‚úÖ | ‚ùå | ‚úÖ | ‚úÖ
| OpenTelemetry OTLP Metrics Exporter | ‚úÖ | ‚ùå | ‚ùå | ‚úÖ
| OpenTelemetry OTLP Traces Exporter | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ
| OpenTelemetry Environment Variables | ‚úÖ | ‚ùå | ‚ö†Ô∏è* | ‚úÖ
| Micrometer Metrics OTLP Exporter | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå
| OpenTelemetry Java Instrumentation | üî∂ | ‚ùå | ‚ùå | ‚úÖ
| Micrometer Instrumentation | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå
| Single Dependency | ‚úÖ | ‚ùå | ‚ö†Ô∏è** | ‚úÖ
| Spring Boot Conventional Patterns | ‚úÖ | ‚úÖ | ‚úÖ | ‚ö†Ô∏è*
| Maintained by the Spring team | ‚ùå | ‚úÖ | ‚úÖ | ‚ùå
|===

* _üöß Support is under development and coming soon._
* _üî∂ When both Micrometer and OpenTelemetry Java instrumentation available, only the Micrometer one is included._
* _‚ö†Ô∏è* Only a subset is supported._
* _‚ö†Ô∏è** Single dependency, but still with partial support for OpenTelemetry, so you'll need to add more dependencies yourself._

=== Arconia OpenTelemetry vs Spring Boot OpenTelemetry

The https://docs.spring.io/spring-boot/reference/actuator/observability.html#actuator.observability.opentelemetry[Spring Boot] project provides observability based on Micrometer with partial support for exporting telemetry for OpenTelemetry.

For logs, it supports the OpenTelemetry Logging API, but no bridges are provided to reuse existing logging instrumentation. For traces, it supports the OpenTelemetry Tracing API via a bridge from Micrometer Tracing.

For metrics, Spring Boot doesn‚Äôt provide support for the OpenTelemetry Metrics API. Instead, it offers an option to export Micrometer metrics via OTLP using the Micrometer Metrics Registry OTLP module.

A key difference between Arconia OpenTelemetry and Spring Boot is that the latter doesn‚Äôt provide full support for OpenTelemetry APIs, SDKs, and Environment Variables.

In particular, by not supporting the OpenTelemetry Metrics API, Spring Boot misses out on the ability to collect metrics using the standard OpenTelemetry APIs and instrumentation, which some Java libraries use.
Additionally, configuration for each observability signal is segregated rather than unified under a single OpenTelemetry configuration model to benefit from consistency and common defaults across all signals.

=== Arconia OpenTelemetry vs OpenTelemetry Spring Boot Starter

The https://opentelemetry.io/docs/zero-code/java/spring-boot-starter[OpenTelemetry Spring Boot Starter] is built on top of the OpenTelemetry Java SDK and Instrumentation libraries. It provides support for OpenTelemetry APIs and SDKs, including logging, metrics, and tracing.

A key difference between Arconia OpenTelemetry and the OpenTelemetry Spring Boot Starter is that the latter doesn‚Äôt reuse most of the existing, stable Micrometer instrumentation available across the Spring and Java ecosystem. Each Spring library comes with built-in instrumentation based on the Micrometer Observation API, implemented and maintained by the same authors.

By not reusing the existing Micrometer instrumentation, the OpenTelemetry Spring Boot Starter misses out on a significant amount of telemetry data, which needs to be implemented and maintained separately by the OpenTelemetry community. That may also lead to compatibility issues whenever new Spring Boot versions are released.

Additionally, the configuration model is not as streamlined as you'd expect from a Spring Boot library, primarily due to the use of an auto-configuration design specific to the OpenTelemetry Java SDK, which doesn't always follow the usual Spring Boot conventions.

Finally, it doesn't offer support for https://docs.spring.io/spring-boot/reference/features/dev-services.html[Spring Boot development-time services] (e.g., Testcontainers or Docker Container), which makes the local development and testing experience less convenient.
